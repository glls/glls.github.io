<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Server | George Litos</title>
    <link>http://localhost:1313/tags/server/</link>
      <atom:link href="http://localhost:1313/tags/server/index.xml" rel="self" type="application/rss+xml" />
    <description>Server</description>
    <generator>Hugo Blox Builder (https://hugoblox.com)</generator><language>en-us</language><lastBuildDate>Sun, 17 Aug 2025 14:49:36 +0300</lastBuildDate>
    <image>
      <url>http://localhost:1313/media/icon_hu_fb37dc6c584384a9.png</url>
      <title>Server</title>
      <link>http://localhost:1313/tags/server/</link>
    </image>
    
    <item>
      <title>A Developer&#39;s Introduction to Unraid</title>
      <link>http://localhost:1313/post/unraid/</link>
      <pubDate>Sun, 17 Aug 2025 14:49:36 +0300</pubDate>
      <guid>http://localhost:1313/post/unraid/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://unraid.net/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Unraid&lt;/a&gt; is a proprietary Linux-based operating system designed for &lt;strong&gt;home servers and small businesses&lt;/strong&gt;. It&amp;rsquo;s known for its unique storage management system, which provides flexibility and data protection. Developers often use Unraid to run a variety of services, including web servers, databases, and CI/CD tools, all on a single machine.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;key-features-for-developers&#34;&gt;Key Features for Developers&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Docker and Virtualization:&lt;/strong&gt; Unraid has built-in support for running Docker containers and virtual machines. This is a major plus for developers, as it allows them to easily deploy and manage isolated application environments. You can run multiple services (e.g., a web server, a database, and a caching layer) in separate containers without them interfering with each other. This is especially useful for testing and production environments.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Flexible Storage:&lt;/strong&gt; Unraid&amp;rsquo;s most distinctive feature is its storage array. It combines drives of different sizes into a single, logical pool. This is unlike traditional RAID, which typically requires drives of the same size. Unraid uses a &lt;strong&gt;parity drive&lt;/strong&gt; (or two for more protection) to protect against a single (or two) drive failure. Data is written directly to individual drives, which makes it easy to add or remove drives without rebuilding the entire array. For developers, this means they can start with a small setup and expand storage as needed without downtime or complex migrations.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Plugin System and Community Apps:&lt;/strong&gt; Unraid has a robust plugin system and a &amp;ldquo;Community Apps&amp;rdquo; store. This allows developers to easily install and manage a wide range of applications, including many useful for development, like Gitlab, Plex, and various reverse proxies. This makes it easy to set up a comprehensive development and media server environment.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;how-it-works&#34;&gt;How it Works&lt;/h2&gt;
&lt;p&gt;Unraid separates its storage into a few key areas:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Array:&lt;/strong&gt; The main storage pool for your data. Drives can be of different sizes.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Parity Drive(s):&lt;/strong&gt; These drives don&amp;rsquo;t store data directly but contain parity information that can be used to &lt;strong&gt;reconstruct a failed drive&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cache Pool:&lt;/strong&gt; An optional, high-speed SSD-based cache. It&amp;rsquo;s often used to temporarily store data before it&amp;rsquo;s moved to the slower hard drives in the array. This significantly improves performance for applications that have frequent read/write operations. Developers can use this for their databases or other I/O-intensive services to speed things up.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;use-cases-for-developers&#34;&gt;Use Cases for Developers&lt;/h2&gt;
&lt;p&gt;Developers can use Unraid for:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Local Development Environment:&lt;/strong&gt; Host your code repositories, databases, and application servers in a single, controlled environment.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CI/CD Pipeline:&lt;/strong&gt; Run self-hosted runners for Gitlab CI, Jenkins, or other CI/CD platforms.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Media and Data Hoarding:&lt;/strong&gt; Use it as a personal media server with Plex or as a centralized backup destination for your projects.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Docker:&lt;/strong&gt; Leverage Docker containers for microservices, development environments, or isolated applications.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Virtual Machines:&lt;/strong&gt; Run various operating systems, like Windows or different Linux distributions, for testing or specialized development tasks.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Remember that you can even develop your own &lt;strong&gt;Community Applications&lt;/strong&gt; and share them with others, like I did, with the templates found at &lt;a href=&#34;https://github.com/glls/Docker-Templates-Unraid&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/glls/Docker-Templates-Unraid&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The Digital Archivist&#39;s Toolkit: Navidrome, Picard, and Supersonic for the Modern Music Collection</title>
      <link>http://localhost:1313/post/music/</link>
      <pubDate>Sun, 17 Aug 2025 14:17:57 +0300</pubDate>
      <guid>http://localhost:1313/post/music/</guid>
      <description>&lt;p&gt;In an age dominated by music streaming, a dedicated community of audiophiles and music lovers is preserving the art of the personal music collection. They are digital archivists, meticulously curating libraries of high-fidelity audio files, from rare vinyl rips to lossless studio masters. This pursuit, however, requires more than just a hard drive full of music; it demands a robust set of tools for organization, management, and playback. This is where the triumvirate of &lt;strong&gt;Navidrome&lt;/strong&gt;, &lt;strong&gt;Picard&lt;/strong&gt;, and &lt;strong&gt;Supersonic&lt;/strong&gt; comes into play, offering a powerful, open-source ecosystem for the serious collector.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;navidrome-your-personal-streaming-service&#34;&gt;Navidrome: Your Personal Streaming Service&lt;/h3&gt;
&lt;p&gt;At the heart of the modern self-hosted music setup lies a server (&lt;a href=&#34;http://localhost:1313/post/unraid/&#34;&gt;UNRAID&lt;/a&gt; in my case), and &lt;a href=&#34;https://www.navidrome.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Navidrome&lt;/a&gt; has emerged as a favorite in this space. Imagine having your very own Spotify, but with your meticulously curated library instead of a corporate-controlled catalog. That&amp;rsquo;s the essence of Navidrome. It is a lightweight, open-source music server that allows you to stream your personal music collection from any web browser or mobile device.&lt;/p&gt;
&lt;p&gt;Unlike commercial streaming services that can abruptly alter their catalogs or downgrade audio quality, Navidrome gives you complete control. It&amp;rsquo;s designed to handle very large music collections, with developers testing it on libraries of up to 900,000 songs. Its resource-efficient nature means it can run smoothly on low-powered devices like a Raspberry Pi, making it accessible to a wide range of users.&lt;/p&gt;
&lt;p&gt;Navidrome&amp;rsquo;s web interface is modern, responsive, and easy to navigate. It automatically scans your library for new files and changes, ensuring your collection is always up-to-date. But its true power lies in its compatibility. Navidrome supports the Subsonic API, a de facto standard for music server clients. This means you can use a variety of third-party mobile apps for iOS and Android, such as DSub, Substreamer, or Ultrasonic, to access your music on the go. This flexibility, combined with features like on-the-fly transcoding to save mobile data and a multi-user system for family and friends, makes Navidrome the cornerstone of a personal music cloud.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;musicbrainz-picard-the-meticulous-librarian&#34;&gt;MusicBrainz Picard: The Meticulous Librarian&lt;/h3&gt;
&lt;p&gt;Before you can stream your music with Navidrome, it needs to be properly organized and tagged. This is where &lt;a href=&#34;https://picard.musicbrainz.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MusicBrainz Picard&lt;/a&gt; steps in as an indispensable tool. A common problem with digital music is inconsistent or missing metadataâ€”the information embedded in audio files like song title, artist, album, and year. A music collection without good metadata is a chaotic mess, a digital junkyard of &amp;ldquo;Track 01&amp;rdquo; files.&lt;/p&gt;
&lt;p&gt;Picard is a cross-platform music tagger that uses the massive, community-maintained MusicBrainz database to identify and tag your audio files with unparalleled accuracy. Its most impressive feature is its use of &lt;strong&gt;AcoustID audio fingerprints&lt;/strong&gt;. This technology allows Picard to &amp;ldquo;listen&amp;rdquo; to a song and identify it based on its unique sonic signature, even if the file has no existing metadata. This is a game-changer for cleaning up poorly organized libraries.&lt;/p&gt;
&lt;p&gt;Beyond identification, Picard offers powerful tools for organization. It can automatically rename your files and sort them into a logical folder structure based on your preferences. For example, you can script it to create folders structured like &amp;ldquo;Artist/Album/Track Number - Title.&amp;rdquo; Picard also finds and downloads the correct cover art, ensuring your music library is not only organized but also visually appealing. By using Picard, you transform a disorganized jumble of files into a clean, searchable, and aesthetically pleasing collection.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;supersonic-the-sleek-desktop-client&#34;&gt;Supersonic: The Sleek Desktop Client&lt;/h3&gt;
&lt;p&gt;While Navidrome&amp;rsquo;s web interface is excellent, many users prefer a dedicated desktop application for their music playback. This is where &lt;a href=&#34;https://github.com/dweymouth/supersonic&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Supersonic&lt;/a&gt; shines. Supersonic is a lightweight, full-featured desktop client designed specifically for self-hosted music servers that support the Subsonic API, including Navidrome.&lt;/p&gt;
&lt;p&gt;Supersonic provides a native desktop experience that is often faster and more responsive than a web browser. It&amp;rsquo;s built with modern technologies and offers a clean, intuitive user interface that makes browsing your music library a pleasure. It includes a built-in 15-band graphic equalizer, allowing you to fine-tune your audio playback. You can also scrobble plays to your server, download songs, albums, or playlists for offline listening, and even access synced lyrics.&lt;/p&gt;
&lt;p&gt;Supersonic addresses a key pain point for self-hosted music enthusiasts: the lack of a high-quality, cross-platform desktop client. While many web interfaces are functional, a native application can provide a more polished and integrated experience. Supersonic fills this gap perfectly, acting as a bridge between your local computer and your personal music server. It allows you to enjoy the best of both worlds: the centralized control and accessibility of a server with the performance and features of a dedicated desktop player.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;the-synergy-of-the-trio&#34;&gt;The Synergy of the Trio&lt;/h3&gt;
&lt;p&gt;The true power of Navidrome, Picard, and Supersonic is not in their individual capabilities but in their synergy. They form a complete workflow for the digital music archivist. First, you use &lt;strong&gt;MusicBrainz Picard&lt;/strong&gt; to clean and tag your music files, ensuring they are perfectly organized and contain rich metadata. Next, you point your &lt;strong&gt;Navidrome&lt;/strong&gt; server to this beautifully curated library. Navidrome then indexes the files and makes them available for streaming anywhere in the world. Finally, you can use &lt;strong&gt;Supersonic&lt;/strong&gt; on your desktop to seamlessly connect to your Navidrome server, giving you a powerful and feature-rich way to listen to your music collection.&lt;/p&gt;
&lt;p&gt;This trio of tools represents a significant shift from the corporate-driven streaming paradigm back to a model of personal ownership and control. By leveraging these open-source projects, music lovers can build a system that is tailored to their needs, respects their privacy, and ensures their music collection remains a vibrant, well-organized part of their digital life.&lt;/p&gt;
&lt;p&gt;As a bonus for Android users, the mobile player &lt;a href=&#34;https://github.com/CappielloAntonio/tempo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tempo&lt;/a&gt; is a highly-regarded and robust alternative, offering a seamless and beautiful interface for accessing your Navidrome library on the go.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The correct way to benchmark your web server</title>
      <link>http://localhost:1313/post/benchmark-webserver/</link>
      <pubDate>Sun, 10 Sep 2023 18:00:00 +0300</pubDate>
      <guid>http://localhost:1313/post/benchmark-webserver/</guid>
      <description>&lt;p&gt;Keeping your web server running smoothly is crucial for a positive user experience. But how do you know it can handle the traffic you expect? Benchmarking is the answer! It allows you to simulate real-world load and measure your server&amp;rsquo;s performance. This post will guide you through using &lt;code&gt;wrk&lt;/code&gt;, a powerful tool for benchmarking your web server.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;wrk&lt;/code&gt; is a fast, user-friendly HTTP benchmarking tool. It&amp;rsquo;s lightweight and easy to install. Once you have wrk set up, you can start crafting your benchmark test. &lt;code&gt;wrk&lt;/code&gt; offers various options to configure your test precisely. You can define the number of threads to simulate concurrent users, the number of connections per thread, and the test duration. &lt;code&gt;wrk&lt;/code&gt; also allows you to specify headers to be sent with each request, mimicking real user behavior.&lt;/p&gt;
&lt;p&gt;Running a &lt;code&gt;wrk&lt;/code&gt; test is straightforward. You provide the URL you want to benchmark along with the desired configuration options. Wrks then bombards your server with simulated traffic, measuring critical metrics like request latency, throughput, and overall system health. After the test concludes, &lt;code&gt;wrk&lt;/code&gt; presents a detailed report. This report showcases valuable data points like average request time, request rate, and connection errors. Analyzing this data helps you identify bottlenecks and areas for improvement in your web server&amp;rsquo;s performance.&lt;/p&gt;
&lt;p&gt;By incorporating &lt;code&gt;wrk&lt;/code&gt; into your routine, you gain valuable insights into your web server&amp;rsquo;s capabilities. This allows you to optimize your server&amp;rsquo;s configuration, ensuring it can handle peak traffic and deliver a seamless user experience.&lt;/p&gt;
&lt;p&gt;Here&amp;rsquo;s an excerpt from the &lt;code&gt;wrk&lt;/code&gt; project&amp;rsquo;s &lt;a href=&#34;https://github.com/wg/wrk&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;README on GitHub&lt;/a&gt; for quick reference:&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;basic-usage&#34;&gt;Basic Usage&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;wrk -t12 -c400 -d30s http://127.0.0.1:8080/index.html
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This runs a benchmark for 30 seconds, using 12 threads, and keeping
400 HTTP connections open.&lt;/p&gt;
&lt;p&gt;Output:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Running 30s test @ http://127.0.0.1:8080/index.html
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  12 threads and 400 connections
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  Thread Stats   Avg      Stdev     Max   +/- Stdev
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    Latency   635.91us    0.89ms  12.92ms   93.69%
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    Req/Sec    56.20k     8.07k   62.00k    86.54%
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  22464657 requests in 30.00s, 17.76GB read
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Requests/sec: 748868.53
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Transfer/sec:    606.33MB
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;command-line-options&#34;&gt;Command Line Options&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    -c, --connections: total number of HTTP connections to keep open with
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                       each thread handling N = connections/threads
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    -d, --duration:    duration of the test, e.g. 2s, 2m, 2h
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    -t, --threads:     total number of threads to use
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    -s, --script:      LuaJIT script, see SCRIPTING
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    -H, --header:      HTTP header to add to request, e.g. &amp;#34;User-Agent: wrk&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        --latency:     print detailed latency statistics
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        --timeout:     record a timeout if a response is not received within
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                       this amount of time.
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;benchmarking-tips&#34;&gt;Benchmarking Tips&lt;/h2&gt;
&lt;p&gt;The machine running wrk must have a sufficient number of ephemeral ports available and closed sockets should be recycled quickly. To handle the initial connection burst the server&amp;rsquo;s listen backlog should be greater than the number of concurrent connections being tested.&lt;/p&gt;
&lt;p&gt;A user script that only changes the HTTP method, path, adds headers or
a body, will have no performance impact. Per-request actions, particularly
building a new HTTP request, and use of response() will necessarily reduce
the amount of load that can be generated.&lt;/p&gt;
&lt;h2 id=&#34;showtime-&#34;&gt;Showtime ðŸš€&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Write a program that can serve a list of 100 albums with a REST like interface (JSON) and measure the performance with wrk&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Here&amp;rsquo;s the project in GitHub with full source code and implementations in more than 8 languages: &lt;a href=&#34;https://github.com/glls/web-service-albums-benchmark&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;web-service-albums-benchmark&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;And the results:&lt;/p&gt;
&lt;p&gt;















&lt;figure  &gt;
  &lt;div class=&#34;flex justify-center	&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://github.com/glls/web-service-albums-benchmark/raw/main/chart.svg&#34; alt=&#34;Chart&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;s clear that Rust and Go are the speed demons when it comes to this particular task. However, threading and concurrency can be a game-changer in terms of performance. The key takeaway is that your server&amp;rsquo;s capabilities play a significant role in determining the optimal approach. For instance, if you&amp;rsquo;re running on a 4-core CPU, don&amp;rsquo;t expect more than 4 threads to run simultaneously - it&amp;rsquo;s like trying to fit too many eggs in one basket! So, before making any changes to your tech stack, take some time to consider these factors and plan accordingly.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
